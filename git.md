## Задание 1. Init repo (optional)

1. Создай папку `my-project`
2. Создай внутри файл `hello.txt`
3. Выполни в контекстном меню папки `my-project` команду `GitExt Create new repository`
4. Убедись, что появилась скрытая папка `.git`
5. Выполни в контекстном меню папки `my-project` команду `GitExt Open repository`.
Пока в репозитории пусто. Так и должно быть.


## Задание 2. Commits

1. Склонируй репозиторий [https://github.com/kontur-courses/git-sheet](https://github.com/kontur-courses/git-sheet)

2. Создай файл `init.md` со следующим содержимым (здесь и далее копировать
надо то, что между ```тройных бэктиков или помечено как код```):
```
## 1. Everything Is Local
### Все работает локально
- `git init` — создать пустой репозиторий
- `git clone <url>` — склонировать репозиторий в новую директорию

```
3. Открой репозиторий, убедись, что в нем есть один коммит: `Initial commit`
4. Нажми кнопку `Commit`, чтобы открыть окно коммита
5. Переведи `init.md` из верхней части в нижнюю часть окна кнопкой `Stage` либо двойным нажатием по имени файла.
Теперь `init.md` находится в `Commit index`
6. Введи в качестве сообщения к коммиту «Add init.md» и сделай коммит кнопкой `Commit`
7. Убедись, что коммит появился в истории коммитов

8. Создай файл `commit.md` со следующим содержимым:
```
## 2. Tree Of Commits
### Хранится последовательность состояний некоторой директории

```
9. Выбери в истории коммитов `Working directory` и убедись, что там есть измененный файл `commit.md`
10. Открой окно коммита и переведи `commit.md` в `Commit index` и закрой окно коммита
11. Выбери в истории коммитов `Commit index` и убедись, что измененный файл `commit.md` теперь находится там
12. Замени содержимое `commit.md` на следующее:
```
## 2. Tree Of Commits
### Хранится последовательность состояний некоторой директории
1. `git add .` — добавить все измененные файлы в индекс
2. `git commit -m <msg>` — записать изменения из индекс в репозиторий
3. `git status -sb` — вывести состояние директории и индекса кратко с указанием текущей ветки
4. `git log --oneline` — вывести список коммитов, связанных с HEAD, в кратком виде
5. `git log --oneline --graph` — вывести историю коммитов, связанных с HEAD, в виде дерева
6. `git log --oneline --graph --all` — вывести историю всех коммитов в виде дерева
7. `gitk` — открыть графическое представление репозитория

```
13. Посмотри историю коммитов. Убедись, что `commit.md` изменен как в в `Working directory`, так и в `Commit index`
14. Открой окно коммита и убедись, что `commit.md` находится как в верхней части окна, так и в нижней,
причем содержимое у файлов разное и при выборе `commit.md` в верхней части показывается отличия от `Commit index`,
а не предыдущего коммита
15. Выполни коммит с сообщением «Add commit.md header»
16. В истории коммитов найди только что созданный коммит и убедись, что в него попали только изменения из `Commit index`
17. Закоммить оставшиеся в `Working directory` изменения с сообщением «Change commit.md»


## Задание 3.1. Tag (optional)

1. Выбери в дереве коммитов последний коммит и создай в нем тег `v0.1` с помощью контекстного меню
2. Перейди на «Initial commit» с помощью команды `Checkout this commit` в контекстном меню
3. Используй пункт главного меню `Commands / Checkout revision`, чтобы перейти на помеченный тегом коммит.
Для этого введи имя тега `v0.1` в поле для ввода ревизии.


## Задание 3.2. Feature branches

1. Создай новую ветку `branch-feature` с помощью контекстного меню.
GitExtensions автоматически сделает checkout на нее,
а значит при следующем коммите именно она сдвинется вслед за `HEAD`.

2. Создай новый файл `branch.md` со следующим содержимым:
```
## 3. Tag To Branch
### Используются именованные ссылки
- `git tag` — вывести список тегов
- `git tag <tagname>` — создать тег
- `git branch` — вывести список локальных веток
- `git branch -av` - вывести список локальных и удаленных веток
- `git branch <branchname>` — создать ветку
- `git branch -d <branchname>` — удалить ветку
- `git checkout <commit>` — переместить HEAD на коммит
- `git checkout <branch>` — переместить HEAD на ветку
- `git checkout -m <branch>` — переместить HEAD, объединить текущие изменения с состоянием ветки
- `git checkout -b <new_branch>` — создать новую ветку и перейти на нее

```
3. Закоммить изменения с сообщением «Add branch.md»

4. Перейди назад на ветку `master`, используя контекстное меню и создай ветку `bullet-feature`
5. Во всех доступных md-файлах замени нумерованные списки на ненумерованные списки.
На примере init.md это выглядит следующим образом.
Было:
```
## 1. Everything Is Local
### Все работает локально
1. `git init` — создать пустой репозиторий
2. `git clone <url>` — склонировать репозиторий в новую директорию

```
Стало:
```
## 1. Everything Is Local
### Все работает локально
- `git init` — создать пустой репозиторий
- `git clone <url>` — склонировать репозиторий в новую директорию

```
Аналогично сделай для `commit.md`.

6. Закоммить изменения с сообщением «Replace with bullets»

7. Перейди назад на ветку `master`, используя контекстное меню
8. Замени содержимое `commit.md` на следующее:
```
## 2. Tree Of Commits
### Git хранит последовательность состояний некоторой директории
1. `git add .` — добавить все измененные файлы в индекс
2. `git commit -m <msg>` — записать изменения из индекс в репозиторий
3. `git status -sb` — вывести состояние директории и индекса кратко с указанием текущей ветки
4. `git show <commit>` — показать содержимое коммита
5. `git log --oneline` — вывести список коммитов, связанных с HEAD, в кратком виде
6. `git log --oneline --graph` — вывести историю коммитов, связанных с HEAD, в виде дерева
7. `git log --oneline --graph --all` — вывести историю всех коммитов в виде дерева
8. `gitk` — открыть графическое представление репозитория

```
9. Закоммить изменения с сообщением «show command for commit.md»
10. Обрати внимание, что история коммитов стала похожа на дерево, а на концах веток этого дерева расположены
метки `master`, `branch-feature`, `bullet-feature`. А вот тег `v0.1`, остался на своем месте.


## Задание 4.1. Merge Conflict

1. Начни вливать `bullet-feature` в `master`: `HEAD` уже находится на `master`, поэтому укажи на `bullet-feature`
и с помощью контекстного меню выбери `Merge into current branch`. Но выполнение `Merge` закончится конфликтом.

2. GitExtensions предложит сразу перейти ко второй части слияния — разрешению конфликтов.
Согласись. Откроется окно `Resolve merge conflicts` со списком файлов с конфликтами.
В списке будет только один файл — `commit.md`.
Конфликт произошел, потому что в этот файл вносились изменения и в `bullet-feature` и в `master`.
Нажми на кнопку `Open in vscode` и в качестве инструмента для объединения изменений откроется VS Code.
Часто конфликты разрешаются выбором варианта из одной из веток, но это не тот случай.
В VS Code нажми `Compare Changes` и убедись, что поменялось все. Придется объединять изменения аккуратно вручную.
Сначала выбери `Accept Both Changes` — теперь текст обоих изменений станет доступен для редактирования.
Затем напиши правильную версию блока. В ней должно быть 6 команд и перед каждой командой должны быть дефисы.
Когда закончишь редактирование сохрани изменения (как обычно `Ctrl+S`),
закрой файл в VS Code и переключись на GitExtensions.

3. GitExtensions сообщит, что все конфликты разрешены и предложит перейти к третьей части слияния — коммиту.
Согласись. Откроектся знакомое окно коммита, в котором в `Commit index` будут показаны все изменения относительно `HEAD`.
В `Commit message` будет указано хорошее подробное сообщение: его можно не менять. Закоммить результаты merge.

4. Убедись, что в результате твоих действий был создан новый коммит, объединяющий две ветви изменений.
`HEAD` сдвинулся на него, а `master` сдвинулся за `HEAD`.


## Задание 4.2. Hidden Conflict

1. Начни вливать `branch-feature` в `master`, как и в прошлый раз.
Конфликтов в этот раз не будет, поэтому шаг разрешения конфликтов будет пропущен.
А еще GitExtensions автоматически сделает commit. Таким образом слияние будет выполнено.

2. Хоть «настоящих» конфликтов нет, после слияния появился «логический» конфликт.
Дело в том, что файл `branch.md` до сих пор содержит нумерованный список.
Замени числа в нем на дефисы, аналогично другим файлам.

3. Теперь пришло время добавить в историю эти изменения.
Простой способ это сделать — коммит с сообщением вида «Fix after merge». Прекрасно работает.
Но можно воспользоваться `Ammend Commit`. Эта команда позволяет дополнить последний коммит дополнительными изменениями.
Открой окно коммита, выбери опцию `Ammend Commit`: в `Commit message` появится сообщение из предыдущего коммита,
затем добавь в `Commit index` файл `branch.md` и сделай commit.
Появится предупреждение о том, что переписывается история. Да, так и есть. Соглашайся.


## Задание 4.3. Fast-Forward Merge

1. Создай ветку `merge-feature` и перейди на нее
2. Создай файл `merge.md` со следующим содержимым:
```
## 4. Merge Them All
### Два состояния можно объединить через merge, mergetool и commit
- `git merge <commit>` — объединить текущую ветку с другой
- `git mergetool` — разрешить имеющиеся конфликты

```

3. Закоммить изменения с сообщением «Add merge.md»
4. Перейди назад на ветку `master`
5. Влей `merge-feature` в `master`
6. Заметь, что в этот раз не только конфликтов не было, но и новый коммит не был создан.
Потому что в `master` не было изменений и для объединения двух веток было достаточно передвинуть `master` на коммит,
на который ссылалась `merge-feature`.


## Задание 5. Rebase

1. Создай ветку `rebase-feature` и перейди на нее
2. Создай файл `rebase.md` со следующим содержимым:
```
## 5. Immutable History
### Нельзя переписать историю — можно создать новую
- `git commit --ammend` — заменить последний коммит ветки на отредактированный с дополнительными изменениями
- `git rebase <upstream>` — применить все коммиты от общего родителя до текущего к `<upstream>`
- `git rebase -i <upstream>` — применить заново все коммиты, указав действие с каждым коммитом
- `git cherry-pick <commit>` — применить указанный коммит к HEAD
- `git stash` — сохранить все модифицированные файлы в виде набора изменений
- `git stash pop` — восстановить последний сохраненный набор изменений и удалить его из списка
- `git stash list` — показать список сохраненных наборов изменений
- `git revert <commit>` — создать коммит, отменяющий изменения из коммита

```
3. Закоммить изменения с сообщением «Add rebase.md»
4. Создай файл `reflog.md` со следующим содержимым:
```
## 6. Hide The Garbage
### Видно только то, на что есть ссылки
- `git gc` — удалить ненужные файлы и оптимизировать локальный репозиторий
- `git clean` — удалить неотслеживаемые файлы из директории
- `git reflog show <ref>` — показать лог действий со ссылкой
- `git reflog` = `git reflog show HEAD` — показать лог действий с HEAD

```
5. Закоммить изменения с сообщением «Add reflog.md»

6. Перейди на ветку `master`
7. Создай файл `reflog.md` со следующим содержимым:
```
## 6. Hide The Garbage
### Lorem ipsum dolor sit amet, consectetur adipiscing elit

```
8. Закоммить изменения с сообщением «Add stub for reflog.md»

9. Установи тег `old-rebase-feature` на коммит, на который ссылается `rebase-feature`
10. Перейди на ветку `rebase-feature`
11. Выполни rebase `rebase-feature` на `master`: `HEAD` уже находится на `rebase-feature`, поэтому укажи на `master`
и с помощью контекстного меню выбери `Rebase current branch to`, а затем `Selected commit`.
При rebase возникнет конфликт.
12. Первый коммит «Add rebase.md» успешно скопирован, а вот «Add reflog.md» по понятным причинам порождает конфликты.
Нажми кнопку `Solve conflicts`, чтобы разрешить конфликты в VS Code.
Несмотря на то, что файлы были созданы в разных ветках, Git видит,
что первые строчки совпадают и по ним конфликта нет. А вот оставшиеся строчки конфликтуют.
Так как в ветке `rebase-feature` был правильный текст, нажми `Accept Incoming Change`,
затем сохрани изменения, закрой файл в VS Code, перейди в GitExtensions и нажми `Continue rebase`.
Раз оба коммита были успешно скопированы, rebase на этом будет закончен.
13. Обрати внимание, что в результате rebase были созданы коммиты «Add rebase.md» и «Add reflog.md».
Хоть они похожи на исходные, все же это новые коммиты с новыми ревизиями.
Ветка `rebase-feature` была перемещена и теперь ссылается на новый коммит.
Старые коммиты остались в репозитории и на последний из них все еще ссылается тег `old-rebase-feature`.
14. Перейди на ветку `master` и влей в него изменения из `rebase-feature`. Это будет fast-forward merge.


## Задание 6. Reflog (optional)

1. Удали тег `old-rebase-feature`. Коммит, на который он ссылался будет скрыт, но продолжит существовать в репозитории.
2. Выбери пункт главного меню `Commands / Show reflog`.
В результате ты увидишь список коммитов, по которым передвигался `HEAD`.
Найди в списке действие `commit: Add reflog.md` и выполни `Copy SHA-1` из контекстного меню.
Ревизия этого коммита скопируется в буфер обмена.
3. Используй пункт главного меню `Commands / Checkout revision`, чтобы перейти на коммит с ревизией из буфера обмена.
4. Убедись, что скрытый коммит найден и снова виден. По крайней мере пока на него ссылается `HEAD`.
5. Перейди на `master`


## Задание 7.1. Fetch from remote

1. Добавь новый репозиторий для синхронизации.
Для этого в меню слева найди `Remotes` и в контекстном меню выбери `Manage`.
В открывшемся окне `Remote repositories` нажми плюс и введи параметры репозитория.
    Name: ext
    Url: https://github.com/kontur-courses/git-sheet-ext
Сохрани изменения с помощью `Save changes`.
Если не справился с GUI, то то же самое можно сделать через консоль одной командой:
`git remote add ext https://github.com/kontur-courses/git-sheet-ext`
И убедиться, что удаленные репозиторий был добавлен с помощью команды `git remote -v`

2. Выбери пункт главного меню `Commands / Pull/Fetch`.
Откроется диалоговое окно `Fetch`. В нем в качестве `Remote` выбери `ext`.
Также убедись, что в `Merge options` выбран пункт `Do not merge, only fetch remote changes`.
Нажми на кнопку `Fetch`, чтобы получить изменения из удаленного репозитория.

3. Убедись, что в истории появилась ветка `ext/sheet-feature` из удаленного репозитория,
а также несколько новых коммитов.


## Задание 7.2. Interactive rebase

1. Выполни `Checkout branch` на ветку `ext/sheet-feature`.
GitExtensions предложить создать связанную локальную ветку с именем `sheet-feature`. Согласись.
В удаленную ветку нельзя коммитить, поэтому создание локальной ветки чаще всего необходимо. Но не обязательно.

2. Выполни интерактивный rebase `sheet-feature` на `master`: укажи на `master` и с помощью контекстного меню
выбери `Rebase current branch to`, а затем `Selected commit interactively`. Откроется текстовый редактор.

3. В текстовом редакторе описан сценарий действий для rebase. Сейчас он заключается в том, что надо взять
и переместить на новое место все коммиты последовательно: сначала первый, затем второй и т.д. Все как обычно.
Ниже сценария приведены комментарии по возможным действиям с коммитами.
Прочитай, что делает `reword`, `squash` и `fixup`.

4. В первой строчке файла замени `pick` на `reword`, а последующих строчках замени `pick` на `fixup`.
Сохрани изменения и закрой текстовый редактор. Редактор откроется снова и в нем надо будет ввести
новое сообщение для «sheet markup». Введи в качестве сообщения «extension».

5. Убедись, что ветка `sheet-feature` теперь ссылается на новый коммит с названием «extension».
А внутри этого коммита объединены все изменения скопированных коммитов.

6. Перейди на ветку `master` и влей в него изменения из `sheet-feature`. Это будет fast-forward merge.

7. Удали ветку `sheet-feature` используя контекстное меню. При удалении выбери `Force delete`,
потому что эта ветка связана с `ext/sheet-feature`, которая в `master` не влита.


## Задание 8. Push Force

1. Создай новый файл `push.md` со следующим содержимым:
```
## 8. Will Push Force be with you
### Изменить удаленный репозиторий — это push
- `git push <remote> <local_branch>:<remote_branch>` — добавить изменения из локальной ветки `<local_branch>` и переместить ветку `<remote_branch>` удаленного репозитория
- `git push` = `git push origin HEAD` — добавить изменения из текущей локальной ветки и переместить соответствующую ветку удаленного репозитория

```
2. Закоммить изменения с сообщением «Add push.md»
3. Сделай push локальной ветки `master` в `master` из `origin` с помощью `Commands / Push` в главном меню.

4. Замени содержимое `push.md` на следующее:
```
## 8. Will Push Force be with you
### Изменить удаленный репозиторий — это push
- `git push <remote> <local_branch>:<remote_branch>` — добавить изменения из локальной ветки `<local_branch>` и переместить ветку `<remote_branch>` удаленного репозитория
- `git push` = `git push origin HEAD` — добавить изменения из текущей локальной ветки и переместить соответствующую ветку удаленного репозитория
- `git push -f` — выполнить `push`, даже если удаленная ветка находится в другом поддереве
- `git push <remote> -d <branch>` — удалить ветку в удаленном репозитории

```
5. Закоммить изменения с опцией `Ammend Commit`, чтобы не создавать лишний коммит.
6. Обрати внимание, что старый коммит остался видимым, ведь на него ссылается `origin/master`.
7. Если сейчас выполнить push, то он завешится ошибкой, т.к. навозможно продвинуть `origin/master`
вперед по истории так, чтобы он стал ссылаться на коммит, на который ссылается `master`.
Поэтому выполни push с опцией force. Простой способ это сделать — выполнить push,
а при возникновении ошибки выбрать `Force push`.


## Задание 9. Upstream

1. Создай ветку `upstream-feature` и перейди на нее
2. Создай новый файл `upstream.md` со следующим содержимым:
```
## 9. Upstream Mode
### Связь локальных и удаленных веток устанавливается явно
- `git branch -vv` — вывести список локальных веток с указанием привязанных к ним upstream-веток
- `git branch -u <upstream> [<branchname>]` — задать upstream-ветку для указанной или текущей ветки
- `git push -u origin HEAD` — создать удаленную ветку, соответствующую локальной и установить между ними upstream-связь, затем добавить изменения из локальной ветки в удаленный репозиторий
- `git checkout <remote_branchname>` — создать локальную ветку, соответствующую удаленной и установить между ними upstream-связь, затем переместить HEAD на нее
- `git pull` = `git pull origin` — получить содержимое основного удаленного репозитория и влить изменения из удаленной ветки в соответствующую локальную ветку
- `git pull --ff-only` — получить содержимое, а затем влить, если возможен fast-forward merge
- `git pull --rebase` — получить содержимое и выполнить rebase локальной ветки на удаленную ветку
- `git config --global push.default simple` — задать simple-режим действий с upstream-связями при push. Это режим по умолчанию в Git 2.0 и выше

```
3. Закоммить изменения с сообщением «Add upstream.md»
4. Начни делать push этой ветки.
GitExtensions предупредит, что ветки в удаленном репозитории еще нет. Надо согласиться.
Затем GitExtensions предупредит, что у ветки `upstream-feature` еще нет связи с удаленной веткой
и предложит ее установить. Тоже надо согласиться.
В результате GitExtensions выполнит примерно такую команду: `push -u origin upstream-feature:upstream-feature`.
То же самое можно сделать через консоль такой командой: `push -u origin HEAD`


## Задание 10.1. Stash

1. Перейди на ветку `master`.
2. Создай ветку `reset-feature` и перейди на нее
3. Создай новый файл `reset.md` со следующим содержимым:
```
## 10. Reset The Difference
### Хранятся файлы, разница вычисляется на лету

```
4. Закоммить изменения с сообщением «Add reset.md»

5. Замени содержимое `reset.md` на следующее:
```
## 10. Reset The Difference
### Хранятся файлы, разница вычисляется на лету
- `git reset --hard <commit>` — переместить текущую ветку на `<commit>`, задать индекс и директорию согласно коммиту, устранив всю разницу
- `git reset --mixed <commit>` — переместить текущую ветку на `<commit>`, задать индекс согласно коммиту, оставить разницу между исходным и новым состоянием в директории
- `git reset --soft <commit>` — переместить текущую ветку на `<commit>`, не задавать индекс и директорию согласно коммиту, а оставить разницу между исходным и новым состоянием в индексе и директории
- `git reset --hard HEAD~1` — отменить последний коммит

```
6. Ты не влил `upstream-feture` в `master`, поэтому придется прервать работу.
Выбери пункт главного меню `Commands / Manage stashes`.
Откроется окно `Stash` для управления сохраненными изменениями.
Нажми `Stash all changes`, чтобы создать новый stash. Закрой окно.
Обрати внимание, что в `Working directory` изменения пропали.
7. Перейди на ветку `master`, влей в нее ветку `upstream-feature`, сделай push.
8. Перейди назад на ветку `reset-feature`.
9. Верни изменения из stash. Для выбери пункт главного меню `Commands / Manage stashes`.
Так как пока сохранен только один stash, просто нажми `Apply Selected Stash`.
Изменения попадут в `Working directory`.
10. Закоммить изменения с сообщением «Change reset.md»
11. Похоже разработка закончена, поэтому можно влить в нее `master` и отдать в тестирование. Влей `master`.


## Задание 10.2. Hard Reset

1. К сожалению ты забыл добавить некоторые изменения в `reset-feature`. Придется отменить merge.
Хорошо, что еще `reset-feature` не запушен.
2. Выбери коммит «Change reset.md» и с помощью контекстного меню выполни `Reset current branch to here`.
В открывшемся окне выбери опцию `Hard`, чтобы полностью затереть все изменения, и выполни reset.
3. Замени содержимое `reset.md` на следующее:
```
## 10. Reset The Difference
### Хранятся файлы, разница вычисляется на лету
- `git reset --hard <commit>` — переместить текущую ветку на `<commit>`, задать индекс и директорию согласно коммиту, устранив всю разницу
- `git reset --mixed <commit>` — переместить текущую ветку на `<commit>`, задать индекс согласно коммиту, оставить разницу между исходным и новым состоянием в директории
- `git reset --soft <commit>` — переместить текущую ветку на `<commit>`, не задавать индекс и директорию согласно коммиту, а оставить разницу между исходным и новым состоянием в индексе и директории
- `git reset --hard HEAD~1` — отменить последний коммит
- `git diff <commit> [<commit>]` — вывести разницу между двумя коммитами
- `git difftool <commit> [<commit>]` - вывести разницу с помощью difftool из настроек

```
4. Закоммить изменения с сообщением «Change reset.md again»
5. Снова влей `master` в `reset-feature`, чтобы в ней были все актуальные изменения.
6. Перейди в `master`. Пришло запушить последнуюю версию. Для этого влей `reset-feature` в `master` и сделай push.
Так как в `master` не произошло изменений с последнего влития `master` в `reset-feature`, это будет fast-forward merge.


## Задание 10.3. Soft Reset

1. Выбери начальный коммит «Initial commit» и с помощью контекстного меню выполни `Reset current branch to here`.
В открывшемся окне выбери опцию `Soft`, чтобы вся разница между коммитами оказалась в `Commit index`, и выполни reset.
2. Создай ветку `solved` и перейди на нее
3. Закоммить изменения с сообщением «Solved»
4. Сделай push
